posso modificare il leak in base a quanti numeri decido di mettere. PRENDE SOLO I NUMERI DISPARI

1 = add_numbers + 67 (valore di ritorno della get_int)

se metto che voglio inserire 6 numeri il loop non finisce mai. Questo perchè i non è mai minore di n_numbers

codice conciso della take numbers prima della printf sospetta
verificare tutto il codice per bene

		     take_numbers                                  
MOV	EAX,dword ptr [RBP + n_numbers]
SHL	RAX,0x2
LEA	RDX,[RAX + 0x8]	; somma a rax +0x8 e salva il valore dentro a RDX
MOV	RAX, 0xF
ADD	RAX,RDX
MOV	ESI,0x10
DIV	RSI		; dentro rdx ci finisce l'ultimo nimble di rax

ulimo nimble di rax = n_numbers * 2 + 0x8 + 0xf

n_numbers	rdx
0		0x7
1		0x9
2		0xb
3		0xe
4		0xf


in base a quanti numeri vuoi mettere lui farà un determinato ciclo e mette i numeri all'interno dello stack ma fino a un certo punto. Dopo rincomincia dallo stack da capo

se metto -10, -11, -12, -13 -> SEG FAULT: non sovrascrive il RIP.. legge in una zona di memoria sbagliata: se noi mettiamo come numero una zona buona invece? niente...
se metto -14, -15, -16, -17 -> STACK SMASHING: sovrascrive il canary ma è un caso.. credo? Comunque può tornare utile

Il while riempie il buffer da 0 a 3
il for riempie numbers da 0 a 4! Nell'ultimo elemento ci finisce la cella dopo l'ultima cella del buffer

SE VOGLIO METTERE 6 NUMERI:
i viene sovrascritta con l'ultimo numero inserito (in questo caso 0 e riparte il conto)
se io come ultimo numero metto uno diverso da zero? Tipo se metto come ultimo numero 11???
il problema è che viene riscritta con una qword invece che una dword+0x4, devo mettere tipo 0x0bffffffff
non va bene perchè non passo il controllo del while con temp_numbers.. prima devo sovrascrivere temp numbers forse..
adesso però lui intanto nel for mi copia lo stack da buffer[0] a buffer[12]..

11 = 0x0bffffffff = 51539607551

quando prepara la stack per temp numbers c'è lo shl 2 e temp numbers è un 4 byte scritto nella parte alta.. 
se noi mettiamo come temp_numbers 0x80000000 con lo shiftleft diventa 2 quindi prepara lo stack come se fosse 2 ma viene salvato in memoria come se fosse 0x80000000


EXECUTION FLOW:
prende temp_numbers
fai un if a caso
setup stack
prende primo numero
for body  write numero in buffer e inc i
for check i < temp_numbers

COME CREA LO STACK:
buffer:	(rsp+0x0f)/16*16
rsp:	rsp - ((number*4+0x08+0x0f)/0x10)*0x10
rdx:	(number*4+0x08+0x0f) % 0x10
rsi:	0x10

STACK con 1
HIGH
RBP+0x8:		sRIP (main: 0x00005555555554b2)	(buffer[9])
RBP:			sRBP				(buffer[8])
RBP-0x08:		canary				(buffer[7])
RBP-0x10:		buffer				(buffer[6])
RBP-0x18:		number				(buffer[5])
RBP-0x1c:		temp_number					
RBP-0x20:		ffffdee8
RBP-0x24:		i
RBP-0x28:		ffffddc0			(buffer[3])
RBP-0x30		buffer[2]
RBP-0x38:		buffer[1]
RBP-0x40, RSP, Buffer:	buffer[0]
LOW
0x7fffffffdd80: 0x00007fffffffddc0      0x0000555555555234
0x7fffffffdd90: 0x0000000000000000      0x00000000ffffddc0
0x7fffffffdda0: 0x00000001ffffdee8      0x0000000000000007
0x7fffffffddb0: 0x00007fffffffdd80      0xfba32af36a60cb00
0x7fffffffddc0: 0x00007fffffffddd0      0x00005555555554b2

STACK con 6
HIGH
RBP+0x8:		sRIP (main: 0x00005555555554b2)	(buffer[11])
RBP:			sRBP				(buffer[10])
RBP-0x08:		canary				(buffer[9])
RBP-0x10:		buffer				(buffer[8]) <- se riscrivo qui, faccio un redirect della scrittura
RBP-0x18:		number				(buffer[7])
RBP-0x1c:		temp_number
RBP-0x20:		ffffdee8			(buffer[6]) <- qui metto 42949672959 = 0x9FFFFFFFF = 9.. dovrebbe continuare a scrivere -> non va, indigare con gdb 
RBP-0x24:		i
RBP-0x28:		ffffddc0			(buffer[5]) <- viene riscritto, se metto i giusto, tipo 5 = 0x05ffffffff = 25769803775, posso continuare e sovrascrivere temp_number..
RBP-0x30		buffer[4]
RBP-0x38		buffer[3]
RBP-0x40		buffer[2]
RBP-0x48		buffer[1]
RBP-0x50, RSP, Buffer:	buffer[0]
LOW

STACK con 0
HIGH
RBP+0x8:		sRIP (main: 0x00005555555554b2)	(buffer[9])
RBP:			sRBP				(buffer[8])
RBP-0x08:		canary				(buffer[7])
RBP-0x10:		buffer				(buffer[6])
RBP-0x18:		number				(buffer[5])
RBP-0x1c:		temp_number					
RBP-0x20:		0				(buffer[4])
RBP-0x24:		i
RBP-0x28:		buffer[3]			(buffer[3])
RBP-0x30		buffer[2]
RBP-0x38		buffer[1]
RBP-0x40, RSP, Buffer:	buffer[0]
LOW
0x7fffffffdd90: 0x00007fffffffddd0      0x0000555555555234
0x7fffffffdda0: 0x0000000000000000      0x0000000000000000
0x7fffffffddb0: 0x0000000000000000      0x0000000000000007
0x7fffffffddc0: 0x00007fffffffdd90      0xa041e93d35466b00
0x7fffffffddd0: 0x00007fffffffdde0      0x00005555555554b2
