MAIN
int __fastcall main(int argc, const char **argv, const char **envp)
{
__int64 vlong_1001; // rax
unsigned int seed; // [rsp+0h] [rbp-1410h] BYREF
int i; // [rsp+4h] [rbp-140Ch]
int rand_file; // [rsp+8h] [rbp-1408h]
unsigned int answer; // [rsp+Ch] [rbp-1404h]
char pnrg[5008]; // [rsp+10h] [rbp-1400h] BYREF
char nptr[104]; // [rsp+13A0h] [rbp-70h] BYREF
unsigned __int64 canary; // [rsp+1408h] [rbp-8h]

canary = __readfsqword(0x28u);
rand_file = open("/dev/random", 0, envp);
read(rand_file, &seed, 4uLL);
close(rand_file);
pnrg_init(pnrg, (int)seed);
for ( i = 0; i <= 999; ++i )
getRandLong(pnrg);
vlong_1001 = getRandLong(pnrg);
printf("%#lx, ", vlong_1001);
puts("guess the seed:");
read(0, nptr, 99uLL);
answer = strtoul(nptr, 0LL, 0);
if ( answer == seed )
{
memset(nptr, 0, 0x64uLL);
rand_file = open("./flag", 0);
read(rand_file, nptr, 0x63uLL);
puts(nptr);
close(rand_file);
}
else
{
printf("your guess was %#x, seed was %#x. Bye!", answer, seed);
}
return 0;
}

PNRG INIT
char *__fastcall pnrg_init(char *pnrg, __int64 seed)
{
char pnrg_temp[5000]; // [rsp+10h] [rbp-1390h] BYREF
unsigned __int64 canary; // [rsp+1398h] [rbp-8h]

canary = __readfsqword(0x28u);
m_pnrg_init(pnrg_temp, seed);
qmemcpy(pnrg, pnrg_temp, 5000uLL);
return pnrg;
}


M_PNRG_INIT
_int64 __fastcall m_pnrg_init(pnrg *pnrg, unsigned int seed)
{
__int64 counter; // rax

pnrg->seed = seed;
for ( pnrg->counter = 1; ; ++pnrg->counter )  // for without any ending condition
{                                             // pnrg[1248] is like as it was a counter
counter = (unsigned int)pnrg->counter;      // take the counter
if ( (int)counter > 0x26F )
break;
*(&pnrg->seed + pnrg->counter) = 6069       // pnrg[counter] = 6069 * pnrg[counter-1]
* (unsigned int)*((_QWORD *)pnrg + pnrg->counter - 1);
}
return counter;
}

GETRANDLONG
unsigned __int64 __fastcall getRandLong(pnrg *pnrg)
{
int counter; // eax
int i; // [rsp+Ch] [rbp-Ch]
unsigned __int64 v4; // [rsp+10h] [rbp-8h]
unsigned __int64 v5; // [rsp+10h] [rbp-8h]
unsigned __int64 v6; // [rsp+10h] [rbp-8h]
unsigned __int64 v7; // [rsp+10h] [rbp-8h]
unsigned __int64 v8; // [rsp+10h] [rbp-8h]

if ( pnrg->counter >= 624u )
{
if ( pnrg->counter >= 625u )
m_pnrg_init(pnrg, 0x1105u);
for ( i = 0; i <= 226; ++i )
{
v4 = *(&pnrg->seed + i) & 0x80000000LL | *(_QWORD *)&pnrg->bytes[2 * i] & 0x7FFFFFFFLL;// long[2]mag_3808
*(&pnrg->seed + i) = mag_3808[v4 & 1] ^ (v4 >> 1) ^ *(_QWORD *)&pnrg->bytes[2 * i + 792];// mag_3808[0] = 0, mag_3808[1] = 0x9908B0DF
}
while ( i <= 622 )
{
v5 = *(&pnrg->seed + i) & 0x80000000LL | *(_QWORD *)&pnrg->bytes[2 * i] & 0x7FFFFFFFLL;
*(&pnrg->seed + i) = mag_3808[v5 & 1] ^ (v5 >> 1) ^ *((_QWORD *)pnrg + i - 227);
++i;
}
v6 = *(_QWORD *)&pnrg->bytes[1244] & 0x80000000LL | pnrg->seed & 0x7FFFFFFF;
*(_QWORD *)&pnrg->bytes[1244] = mag_3808[v6 & 1] ^ (v6 >> 1) ^ *(_QWORD *)&pnrg->bytes[790];
pnrg->counter = 0;
}
counter = pnrg->counter;
pnrg->counter = counter + 1;
v7 = ((unsigned __int64)*(&pnrg->seed + counter) >> 11) ^ *(&pnrg->seed + counter);
v8 = ((((_DWORD)v7 << 7) & 0x9D2C5680 ^ (unsigned int)v7) << 15) & 0xEFC60000 ^ ((_DWORD)v7 << 7) & 0x9D2C5680 ^ v7;
return (v8 >> 18) ^ v8;
}
